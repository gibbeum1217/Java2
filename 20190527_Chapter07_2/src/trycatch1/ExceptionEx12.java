/* 예외를 처리하는 방법에는 지금까지 배워 온 try-catch문을 사용하는 것 외에, 예외를 메서드에 선언하는 방법이 있다 ★
 * 메서드에 예외를 선언하려면 ★메서드의 선언부에 키워드 throws를 사용해서 메서드 내에서 발생할 수 있는 예외를 적어주기만 하면된다
 * 그리고 예외가 여러개일 경우에는 쉼표(,)로 구분한다.
 * 
 * void method() throws Exception1, Exception2, ... ExceptionN{
 * 
 * }
 * 
 * 
 * 만일 아래와 같이 모든 예외의 최고조상인 Exception클래스를 메서드에 선언하면, 이 메서드는 모든 종류의 예외가 발생할 가능성이 있다는 뜻이다
 * void method() throws Exception{
 * 
 * 메서드의내용
 * 
 * }
 * 
 * 이렇게 예외를 선언하면, 이 예외뿐만 아니라 그 자손타입의 예외까지도 발생할 수 있다는 점에 주의하자
 * 앞서 오버라이딩에서 살펴본 것과 같이, 오버라이딩할때는 단순히 선언된 예외의 개수가 아니라 상속관계까지 고려해야 한다
 * 
 * 메서드의 선언부에 예외를 선언함으로써 메서드를 사용하려는 사람이 메서드의 선언부를 보았을 때, 이 메서드를 사용하기 위해서는 어떠한 예외들이 처리되어져야 하는지 쉽게 알 수 있다
 * 	기존의 많은 언어들에서는 메서드에 예외선언을 하지 않기 때문에, 경험 많은 프로그래머가 아니고서는 어떤 상황에 어떤 종류의 예외가 발생할 가능성이 있는지
 * 충분히 예측하기 힘들기 때문에 그에 대한 대비를 하는 것이 어려웠다. 
 *        그러나 자바에서는 메서드를 작성할 때 메서드 내에서 발생할 가능성이 있는 예외를 메서드의 선언부에 명시하여 
 *        이 메서드를 사용하는 쪽에서는 이에 대한 처리를 하도록 강요하기 때문에,프로그래머들의 짐을 덜어주는것은 물론이고 보다 견고한 프로그램 코드를 작성할 수 있도록 도와준다.
 *        
 *        *예외를 발생시키는 키워드throw와 예외를 메서드에 선언할때 쓰이는 throws를 잘 구별하자.
 *        
 *        
 *        public final void wait()
 *        			throws InterruptedException
 *        
 *        java.lang.Object클래스의 wait메서드에 대한 설명이다 
 *        메서드의 선언부에 InterruptedException이 키워드 throws와 함꼐 적혀 있는 것을 볼 수 있다
 *        이것이 의미하는 바는 이 메서드에서는 InterruptedException이 발생 할 수 있으니, 이 메서드를 호출하고자 하는 메서드에서는 InterruptedException을 
 *        처리해주어야 한다는 것이다
 *        
 *        InterruptedException은 Exception클래스의 자손임을 알 수 있다
 *        따라서 InterruptedException은 반드시 처리해주어야 하는 예외임을 알 수 있다
 *        그래서 wait메서드의 선언부에 키워드 throws와 함께 선언되어져 있는 것이다
 *        
 *        지금까지 알아본 것처럼, 메서드에 예외를 선언할 때 일반적으로 RuntimeException클래스들은 적지 않는다
 *        이 들을 메서드 선언부의 throws에 선언한다고 해서 문제가 되지는 않지만, 보통 반드시 처리해주어야하는 예외들만 선언한다
 *        
 *        사실 예외를 메서드의 throws에 명시하는 것은 예외를 처리하는 것이아니라, 자신(예외가 발생할 가능성이 있는 메서드)을 호출한 메서드에게 예외를 전달하여
 *        예외처리를 떠맡기는 것이다. 
 *        예외를 전달받은 메서드가 또다시 자신을 호출한 메서드에게 전달할 수 있으며, 이런 식으로 계속 호출스택에 있는 메서드들을 따라 전달되다가
 *        제일 마지막에 있는 main메서드에서도 예외가 처리되지 않으면, main메서드마저 종료되어 프로그램이 전체가 종료된다.
 * 
 */


package trycatch1;

public class ExceptionEx12 {

	public static void main(String[] args) throws Exception{
		method1(); //같은 클래스내의 static멤버이므로 객체생성없이 직접 호출가능
	}//main메서드의 끝
	static void method1() throws Exception{
		method2();
	}
	
	static void method2() throws Exception{
		throw new Exception();
	}

}

/* 위의 실행결과를 보면, 프로그램의 실행도중 java.lang.Exception이 발생하여 비정상적으로 종료했다는 것과 예외가 발생했을 떄 호출스택의 내용을 알 수 있다


   예외가 발생했을때, 모두 3개의 메서드(main, method1, method2)가 호출스택에 있었으며
예외가 발생한곳은 제일 윗줄에 있는 method2()라는 것과
main메서드가 metho1()을 그리고 method1()은 method2()를 호출했다는 것을 알 수 있다

 위의 예제를 보면 method2()에서 throw new Exception();문장에 의해 예외가 강제적으로 발생했으나 try-catch문으로 예외처리를 해주지 않았으므로
method2()는 종료됨녀서 예외를 자신을 호출한 method1()에게 넘겨준다
method1()에서도 역시 예외 처리를 해주지 않았으므로 종료되면서 main메서드에게 예외를 넘겨준다 ★
  그러나 main메서드에서 조차 예외처리를 해주지 않았으므로 main메서드가 종료되어 프로그램이 예외로 인해 비정상적으로 종료되는 것이다

이처럼 예외가 발생한 메서드에서 예외처리를 하지 않고 자신을 호출한 메서드에게 예외를 넘겨줄수는 있지만, 이것으로 예외가 처리된 것은 아니고 예외를 단순히 전달만 하는 것이다
결국 어느 한곳에서는 반드시 try-catch문으로 예외처리를 해주어야 한다 ★

*/

